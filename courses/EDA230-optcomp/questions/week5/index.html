<!DOCTYPE html>
<html class="no-js">
  <head>
    <meta charset="utf-8"/>
    <meta content="IE=edge,chrome=1" http-equiv="X-UA-Compatible"/>
    <title>
      Datateknik-lth
    </title>
    <meta name="description"/>
    <meta content="width=device-width" name="viewport"/>
    <link href="../../../../stylesheets/application-b333b82b.css" rel="stylesheet" type="text/css" />
    <script src="../../../../javascripts/application-ae519d42.js" type="text/javascript"></script>
  </head>
  <body>
    <div class="page-content">
      <div class="wrapper">
        <ol>
  <li>2.</li>
  <li>The instruction scheduler tries to rearrange the code so that many
expressions are computed concurrently. By computing expressions
concurrently, however, more registers are needed resulting in what's
called <em>register pressure</em>.</li>
  <li>How - see book 233
Why - avoid pipeline stalls</li>
  <li><code>(sigma(v) + i) mod II</code></li>
  <li>Loop's can use their own indices</li>
</ol>

<h1 id="terminology">Terminology</h1>

<h2 id="matrix-distance">Matrix distance</h2>

<p>Let's say we have the following:</p>

<p>```c
float a[N][M], b[N][M], c[N][M];</p>

<p>void foo()
{
    int     i, j;</p>

<pre><code>for (i = 2; i &lt; 100; i++) {
    for (j = 2 + 3 * i; j &lt; 1000; j++) {
        a[ i ][ j ] = [ i - 2 ][ j + 3 ];
        b[ i ][ j ] = [ i     ][ j - 2 ];
        c[ i ][ j ] = [ i + 1 ][ j + 2 ];
    }
} } ```
</code></pre>

<p>Finding the distance matrix of the loop above is done as follows.
We start of with calculating the distance vector for the <code>a</code> vector.</p>

<p>```
IA + a0 = JB + b0</p>

<p>where</p>

<p>A   = [1 0; 0 1]
a0  = [0 0]</p>

<p>B   = [1 0; 0 1]
b0  = [-2 3]
```</p>

<p>We then re-write <code>IA + a0 = JB + b0</code> to:</p>

<p><code>
[I J][A; -B] = [i1 j1 i2 j2][A; -B] = b0 - a0
</code></p>

<p>For the <code>a</code> vector this results in:</p>

<p>```
             [  1  0 ]
[i1 j1 i2 j2]|  0  1 | = [-2 3] - [0 0]
             | -1  0 | 
             [  0 -1 ]</p>

<p>```</p>

<p>Which in turn gives us:</p>

<p>```
(i1 - i2, j1 - j2) = (-2, 3)</p>

<p>if I = (t1, t2) =&gt;</p>

<p>i1 - i2 = -2 =&gt; i2 = t1 + 2
j1 - j2 =  3 =&gt; j2 = t2 - 3</p>

<p>=&gt;</p>

<p>J = (t1 + 2, t2 - 3)</p>

<p>=&gt;</p>

<p>d_a = (2, -3)
```</p>

<p>In the case of the last vector's distance vector <code>d_c</code> we get a vector
that's negative when first examined. However we want a vector that's
lexicographically positive. As such we must check whether <code>I-J</code> or <code>J-I</code>
gives a positive distance vector. In this case <code>J - I</code> gives a positive
vector <code>d_c = (1, 2)</code>.</p>

<h3 id="tip">TIP!</h3>
<p>If both <code>(x, y)</code> are positive then the read occurs before the write.</p>

<h1 id="hyperplane-method">Hyperplane Method</h1>
<p>The Hyperplane Method is a way to enable parallel execution of all loops
except the outermost. Given a perfect loop nest <code>L</code> and a distance matrix
<code>D</code>, the method finds a <code>m x m</code> unimodular matrix <code>U</code>, this matrix carries
all the dependencies in the outermost loop <code>L1</code>. All inner loops <code>L2..Lm</code>
can be executed in parallel, as long as all elements in the first column
are <code>&gt;= 1</code>.</p>

<p>Determine <code>U</code> by using the following system, where it is required that the
first column is (for all elements) <code>&gt;= 1</code>.
<code>d1 x u &gt;= 1</code> â€¦. <code>dn x u &gt;= 1</code>, where <code>u = (u1, u2... um)</code>, the first
column of <code>U</code>.</p>

<p>U can be determined by 
<code>
                                 | u1 1 0 0 |
U = [ u; [ I_(m-1); zeroes ] ] = | u2 0 1 0 |
                                 | u3 0 0 1 |
                                 | um 0 0 0 |
</code></p>

      </div>
    </div>
  </body>
</html>
